https://chatgpt.com/c/69a0b15e-21f4-838b-abee-17862b6a111b

   app                       app
    |                         |
    | AP                      | AP
    |                         |
   node                     node
    |                         |
    | DAP                     | DAP
    |          Peer           |
Transport --------------- Transport

DAP - Decentralization Address Protocol
AP - Application Protocol


Сущности:

app (приложения):
  Events - события
  Message - передача сообщений
  Call - звонок голосом
  VideoCall - Видеозвонок
  Relay (Распаковывает пакет сообщения и отправляет его дальше)
  GateWay (выход в интернет) - использует TUN устройство, реализует выход в сеть
  BorderMapRouter (мапит сервис по ipv4/ipv6 адресу и порту и протоколу (udp/tcp/...) на приложение) - чтобы пользователи могли писать свои приложения
  Objects (файлы, изображения, видео)
  Streaming (видеострим на широкую публику)

Параметры app:
- app_id - Blake3 размером 4 байта от node_id и идентификатора ресурса (байтовая строка, для Message - "Message" и тд). По идее, должен заменить порт

node - участник сети, может участвовать как в DHT, так и быть точкой входа для клиентов / приложений
- node_id - blake3 хеш публичного ключа, длинной 256 символов
- public_key - публичный ключ для подписи
- private_key - приватный ключ (ed25519, но в будущем можно заменить на любой другой)


Transport - сущность, которая связывает ноды по unix socket / tcp / udp / tls / wss / http(s) / socks / ...


DAP - протокол децентрализованной адресации. Ключевая особенность - адреса имеют размер 32 байта (256 бит) и являются хешем от публичного ключа. Поля:
- version (1 байт)
- hop_limit (1 байт)
- flags (пока не представляю какие, но зарезервирую)
- dst node_id
- src node_id
- payload_length
- payload



AP - Application protocol (как замена tcp/udp)
- version
- need_response: да | нет?
- src app_id - 4 байта blake3 от node_id и идентификатора ресурса
- dst app_id - 4 байта blake3 от node_id и идентификатора ресурса, куда возвращать запрос
- payload_length
- payload





У нас есть Node - которая подключается к другим. Каждая Node имеет параметры:
- node_id (blake3 от публичного ключа, длинна 256 бит или 32 байта)
- algo - алгоритм подписи (пока ed25519, но нужно оставить возможность заменить)
- public_key
- private_key
- dht_addressing (bool - true - участвует в адресации DHT, false - нет)

- BootstrapPeers (список):
  - peer: node_id
    transport: (по типу, как у libp2p адресация устроена)
    pub_key: ...
  - peer: node_id
    transport: (по типу, как у libp2p адресация устроена)
    pub_key: ...
  - ...

- apps:
  - app: Node  # главная сущность, отвечает за DHT
    use: false | true (default false)  # по умолчанию, нужно включить режим, чтобы нода играла роль участника DHT
  - app: Message  # Сообщение от участника сети другому участнику
  - app: Relay  # указывает, что нода может выступать в качестве релея (те, одна нода может общаться со списком релеев, но трафик сам уже будет идти через эти самые релеи)
  - app: GateOut  # Выход в публичную сеть (по факту тот же VPN)
  - app: GateIn  # Сущность для входа в сеть, локально TUN интерфейс и перекидывает трафик на GateOut (по факту тот же VPN)
  - app: Objects  # Хранение объектов (файлы)
  - app: Events  # События сети, пока не придумал какие ему параметры выдать
  - app: Call
  - app: VideoCall
  - app: Stream  # стрим (по типу как у твича)



В начале работы, пользователю предлагается выбор - настроить всё вручную, либо сделать автоматически. 
Для этого, он вводит команду:
```
dsn config init
```
генерирует конфиг, публичный и приватный ключ (опционально можно выбрать ed25519 или другой поддерживаемый (пока их не будет))

Также, опционально, можно выбрать директорию для конфигурации (рядом положаться публичный и приватный ключ)

Конфиг по умолчанию генерируется в директории: `~/.overlay/`
А проверяется в таком порядке:
 - `~/.overlay/`
 - `/etc/overlay/`

пример конфига:
```
node_id: blake3 от публичного ключа размером 256 бит
participate_in_dht: true | false (default false)
pid_file: ... 
admin_socket: ... (для управления)

identity:
  public_key: путь до файла или base64
  private_key: путь до файла или base64
  algo: алгоритм (ed25519)

BootstrapPeers:
 - transport (libp2p формат)
   public_key: base64 format
   algo: ed25519 (или другой)
 - ...

Listen:  # по умолчанию отсутствует, указывает, на каких транспортах принимать соединения
 - ... (формат как в yygdrasil)
 - TransoportN ...

Whitelist:
 - peer_public_key - разрешить подключения только для указанных публичных ключей

interface: dsn0
BorderMap:  # маппинг app_id на сеть
  - app_name: SomeApp  # app_id вычисляется как blake3 от node_id+app_name длинной 4 байта
    target: tcp://127.0.1.123:3306
    (ну и всякие доп параметры)
  - app_name: ...
    target: unix:///.....

```

Конфиг может быть в одном из форматов: ini, yaml (yml), json, toml (toml по умолчанию используется)

Дальше, пользователь может провалидировать так:
```
dsn [--config path] config validate
```
И в дальнейшем, любая загрузка конфига требует валидации

При валидации:
1. проверяется, что node_id == blake3(публичного ключа) размером 256 бит, если не так, то выводиться предупреждение и node_id берется тот, что от публичного ключа (тот, что в конфиге игнорируется)
2. тестово подписывается сообщение и проверяется подпись - если все ок продолжаем, если нет - завершаем работу, тк критическая ошибка
3. 

Перегенерировать публиный и приватный ключ может так:
```
dsn [--config path] config keygen [--type ed25519|..]
```

Дальше, клиент может запустить:
```
dsn [--config path] node up (поднимает как демон, с pid и управляющим socket)
```

и обменяться ChaCha20-Poly1305 ключами через KEM с постквантовым шифрованием (в качестве подтверждения - делается подписть приватным ключем и прикладывается публичный (чтобы никто не мог подменить))

Ключи нужны для сквозного шифрования (используется везде, где возможно)

например, такой командой:
```
dsn [--config path] exchange request {node_id}
```

другие вариации:
```
dsn [--config path] exchange response {node_id}
dsn [--config path] exchange list [--sender node_id (фильтр, опционально)]
```

И дальше отправить сообщение:
```
dsn [--config path] message send node_id "message"
```

А другой может сделать так:
1. выполнить:
```
dsn [--config path] message subscribe
```
и получать в реальном времени
2. настроить сохранение сообщений и потом их получать
```
dsn [--config path] message get [--sender node_id]
```

Адресация происходит по DHT с приоритетом по пингу и загруженности (ноды обмениваются информацией между собой)

